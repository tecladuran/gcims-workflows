---
title: "Removing External Variability from GC-IMS Data: Linear Orthogonalization Approach"
author: "Tecla Duran Fort"
date: "`r Sys.Date()`"
output:
  github_document:
    toc: yes
  pdf_document:
    toc: yes
    fig_caption: yes
  html_document:
    toc: yes
    df_print: paged
always_allow_html: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,
                      fig.path = "orthogonal_correction_files/figure-latex/")
library(ggplot2)
library(dplyr)
library(tidyr)
library(tibble)
library(lubridate)
library(reshape2)
source("../../load_gcims_tools.R")
```

Load Peak Table

```{r load-data}
df <- read.csv("../../data/peak_table_var.csv")
```

## 1. Introduction

This document presents the implementation of a correction for GC-IMS Peak Table data. The aim is to remove systematic variability associated with external factors such as elapsed time and batch effects, which may obscure relevant chemical information.

The dataset under study originates from a single urine pool and is used to illustrate the orthogonalization approach, its mathematical foundations, R implementation, and the effect of sequential corrections applied in different orders.

As previously discussed in the [stability analysis report](https://github.com/tecladuran/gcims-workflows/blob/main/docs/stability_analysis.md), both elapsed time and batch number exhibit clear linear trends across the dataset and account for a substantial portion of the total variance. This motivates the use of orthogonalization techniques to isolate the relevant chemical signal from these external influences.

## 2. Theoretical Background

Orthogonal projection methods are commonly used in chemometrics and metabolomics to remove unwanted variability from experimental data. According to Roger et al. (2003), the signal space $\mathcal{S}$ can be decomposed into three orthogonal components:

$$
\mathcal{S} = \mathcal{C} \oplus \mathcal{G} \oplus \mathcal{R}
$$

where $\mathcal{C}$ contains meaningful chemical information, $\mathcal{G}$ represents systematic effects from external variables (e.g., time, batch), and $\mathcal{R}$ captures residual noise.

The aim is to estimate $\mathcal{G}$ and project the data onto its orthogonal complement, thereby removing the external component while preserving the informative signal. Roger et al. (2003) describe two main strategies to estimate this subspace:

-   by identifying the part of $X$ that is orthogonal to the response variable $Y$ (as in OSC or O-PLS),
-   or by directly modelling the subspace associated with the external parameter.

In the present project, we follow the second approach.

From a matrix $X \in \mathbb{R}^{n \times p}$, one can determine and use orthogonal projections (OPs) in the **sample space** or in the **signal space**:

-   An OP in the **sample space** is an $n \times n$ matrix, which acts on the **rows** of $X$ and consequently **left multiplies** $X$ .
-   An OP in the **signal space** is a $p \times p$ matrix, which acts on the **columns** of $X$ and consequently **right multiplies** $X$ .

Sample space OPs are used to separate sources of information related to the collection of the $n$ samples. Signal space OPs are used to separate signal features.

Corrections in the signal space are common for spectral data with fixed variable order and include methods like External Parameter Orthogonalisation.

However, in our case, the data consists of **peak tables**, where features are heterogeneous, non-ordered, and dataset-dependent. Applying projections in the signal space is thus not meaningful in this context.

Instead, we apply orthogonal projections in the **sample space**, removing components aligned with known external variables (e.g., elapsed time or batch).

Let $X \in \mathbb{R}^{n \times p}$ be the matrix of sample intensities (rows = samples, columns = peaks), and let $v \in \mathbb{R}^n$ be an external variable (e.g., elapsed time). We aim to remove from $X$ the component that is linearly aligned with $v$.

First, we **center** both $X$ and $v$ to eliminate constant offsets:

-   Let $\tilde{X} = X - \bar{X}$ (column-wise centering)
-   Let $\tilde{v} = v - \bar{v}$

Then, for each column $x_j$ of $\tilde{X}$, we compute its projection onto $\tilde{v}$ using:

$$
\text{proj}_{\tilde{v}}(x_j) = \frac{\tilde{v}^T x_j}{\tilde{v}^T \tilde{v}} \cdot \tilde{v}
$$

Stacking all projected components together:

$$
\tilde{X}_{\text{proj}} = \frac{\tilde{v} \tilde{v}^T}{\tilde{v}^T \tilde{v}} \cdot \tilde{X}
$$

This expression defines the **projection matrix** $P$:

$$
P = \frac{\tilde{v} \tilde{v}^T}{\tilde{v}^T \tilde{v}} \quad \Rightarrow \quad \tilde{X}_{\text{proj}} = P \tilde{X}
$$

The corrected data is obtained by subtracting the projection:

$$
\tilde{X}_{\text{corr}} = (I - P)\tilde{X}
$$

Finally, we add back the mean to preserve the original intensity scale:

$$
X_{\text{corr}} = \tilde{X}_{\text{corr}} + \bar{X}
$$

This sample space correction is mathematically simple, interpretable, and especially suited for **peak table** data.

It corresponds to a **linear orthogonalization** of the data against the external variable $v$, targeting the most dominant and evident source of drift in the dataset.

For more than one external variable, let

$$
V \in \mathbb{R}^{n \times k}
$$

be the matrix containing the $k$ centered external variables as its columns (e.g., elapsed time and batch). The projection matrix onto the subspace spanned by these variables is given by

$$
P = V \,(V^{T} V)^{-1} V^{T}.
$$

Applying this projection to the centered data $\tilde{X}$ yields the component aligned with the external variables:

$$
\tilde{X}_{\text{proj}} = P \tilde{X}.
$$

The corrected data, orthogonal to all the external variables simultaneously, is obtained as

$$
\tilde{X}_{\text{corr}} = (I - P)\tilde{X}.
$$

Finally, the mean is added back to preserve the original scale:

$$
X_{\text{corr}} = \tilde{X}_{\text{corr}} + \bar{X}.
$$

This joint formulation directly removes all components of the data aligned with the subspace defined by the external variables.

#### Methodological Considerations

Removing variation aligned with external variables risks discarding relevant signal if both are correlated. In this study, all samples come from the same pool, so time-related effects can safely be treated as artefacts. However, in datasets with true biological differences, **confounding** with acquisition order may lead to loss of meaningful information. Proper **randomization** is essential to avoid this.

## 3. Implementation

The following function implements a linear orthogonalization procedure that removes the component of the signal aligned with one or more known external variables (e.g., elapsed time, batch index). This is achieved by computing the projection of each feature onto the subspace spanned by the centered external variables and subtracting it from the data.

The function returns both the corrected data and the removed projection component.

```{r orth-function}
orthogonal_correction <- function(data, variables){
  # Convert to numeric matrices
  data <- as.matrix(data)
  variables <- as.matrix(variables)
  
  # Center data
  data_mean <- colMeans(data)
  data_centered <- sweep(data, 2, data_mean, "-")
  
  # Center external variables
  V_centered <- scale(variables, center = TRUE, scale = FALSE)
  
  # Compute projection matrix P
  XtX <- crossprod(V_centered)              # k x k
  XtX_inv <- solve(XtX)                     # k x k
  P <- V_centered %*% XtX_inv %*% t(V_centered)  # n x n
  
  # Projected component (aligned with external variables)
  projection <- P %*% data_centered         # n x p
  
  # Corrected data (orthogonal part)
  corrected_data <- data_centered - projection
  corrected_data <- sweep(corrected_data, 2, data_mean, "+")
  
  return(list(corrected = corrected_data, projection = projection))
}
```

## 4. Application to Peak Table

The orthogonalization function is applied to the GC-IMS peak intensity matrix using both elapsed time and batch variables simultaneously. This removes the components aligned with the subspace spanned by these external variables in a single step.

```{r apply-correction}
intensities <- df %>% dplyr::select(starts_with("Cluster"))

# Correction for both elapsed time and batch
corrected_intensities <- orthogonal_correction(
  intensities, 
  df %>% dplyr::select(elapsed_time, batch)
)

# Extract corrected data and projection
intensities_final <- corrected_intensities$corrected
projection_both <- corrected_intensities$projection
```

## 5. Method Visualization

Although the correction is formally implemented using both elapsed time and batch simultaneously, it is instructive to visualize the procedure step by step. We first show the sequential removal of elapsed time followed by batch, and then the reverse order. These results confirm that in this dataset the order of application does not affect the final corrected signal, since both variables span an orthogonal subspace. Finally, we show the equivalent correction performed in a single step, where both effects are removed simultaneously.

### 5.1. Sequential Correction

#### Elapsed Time Followed by Batch

.

```{r, echo=TRUE}
# Correction for elapsed time 
corr_time_o1 <- orthogonal_correction(intensities, df$elapsed_time)
intensities_time_corr_o1 <- corr_time_o1$corrected

# Correction for batch 
corr_batch_o1 <- orthogonal_correction(intensities_time_corr_o1, df$batch)
intensities_final_o1 <- corr_batch_o1$corrected

# Components for visualization
time_projection_o1 <- corr_time_o1$projection
batch_projection_o1 <- corr_batch_o1$projection
```

```{r correction-visualization, fig.width=6, fig.height=1.5, echo=FALSE}
# Build visualization dataframe
example_cluster <- intensities[, 18]

# Calcular la mitjana del senyal original
signal_mean <- mean(example_cluster)

# Construir dataframe amb senyals centrades
df_vis_o1 <- data.frame(
  Sample = 1:length(example_cluster),
  Original = example_cluster - signal_mean,
  Time_Component = time_projection_o1[, 18],
  After_Time_Correction = example_cluster - signal_mean - time_projection_o1[, 18],
  Batch_Component = batch_projection_o1[, 18],
  Fully_Corrected = intensities_final_o1[, 18] - signal_mean
)

# Actualitzar el límit comú per a l'eix Y
y_limits_o1 <- range(df_vis_o1)

# 1. Centered Original Signal
ggplot(df_vis_o1, aes(x = Sample, y = Original)) +
  geom_line(color = "#253494", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "1. Original Signal", x = "Sample", y = "Centered Intensity") +
  ylim(y_limits_o1) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

# 2. Elapsed Time Component
ggplot(df_vis_o1, aes(x = Sample)) +
  geom_line(aes(y = Original), color = "#253494", size = 1, alpha = 0.5) +
  geom_line(aes(y = Time_Component), color = "#457b9d", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "2. Time Component",
       x = "Sample", y = "Centered Intensity") +
  ylim(y_limits_o1) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

# 3. After Time Correction
ggplot(df_vis_o1, aes(x = Sample, y = After_Time_Correction)) +
  geom_line(color = "#1c9099", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "3. After Time Correction", x = "Sample", y = "Centered Intensity") +
  ylim(y_limits_o1) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

# 4. Batch Component
ggplot(df_vis_o1, aes(x = Sample)) +
  geom_line(aes(y = After_Time_Correction), color = "#1c9099", size = 1, alpha = 0.5) +
  geom_line(aes(y = Batch_Component), color = "#e9c46a", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "4. Batch Component",
       x = "Sample", y = "Centered Intensity") +
  ylim(y_limits_o1) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

# 5. Final Corrected Signal
ggplot(df_vis_o1, aes(x = Sample, y = Fully_Corrected)) +
  geom_line(color = "#006d2c", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "5. Final Corrected Signal", x = "Sample", y = "Centered Intensity") +
  ylim(y_limits_o1) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())


```

#### Reverse Order

After visualizing the sequential correction (elapsed time followed by batch), we now apply the same procedure in reverse order. This serves to confirm whether the correction is stable and order-independent for this dataset.

```{r, echo=TRUE}
# Apply corrections in reverse order
corr_batch_o2 <- orthogonal_correction(intensities, df$batch)
intensities_batch_corr_o2 <- corr_batch_o2$corrected

corr_time_o2 <- orthogonal_correction(intensities_batch_corr_o2, df$elapsed_time)
intensities_final_o2 <- corr_time_o2$corrected

batch_projection_o2 <- corr_batch_o2$projection
time_projection_o2 <- corr_time_o2$projection
```

```{r inverse, fig.width=6, fig.height=1.5, echo=FALSE}
# Select same cluster and center
example_cluster_o2 <- intensities[, 18]
signal_mean_o2 <- mean(example_cluster_o2)

df_vis_o2 <- data.frame(
  Sample = 1:length(example_cluster_o2),
  Original = example_cluster_o2 - signal_mean_o2,
  Batch_Component = batch_projection_o2[, 18],
  After_Batch_Correction = example_cluster_o2 - signal_mean_o2 - batch_projection_o2[, 18],
  Time_Component = time_projection_o2[, 18],
  Fully_Corrected = intensities_final_o2[, 18] - signal_mean_o2
)

y_limits_o2 <- range(df_vis_o2)

# 1. Original Signal
ggplot(df_vis_o2, aes(x = Sample, y = Original)) +
  geom_line(color = "#1D3557", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "1. Original Signal", x = "Sample", y = "Centered Intensity") +
  ylim(y_limits_o2) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

# 2. Batch Component
ggplot(df_vis_o2, aes(x = Sample)) +
  geom_line(aes(y = Original), color = "#1D3557", size = 1, alpha = 0.5) +
  geom_line(aes(y = Batch_Component), color = "#e9c46a", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "2. Batch Component", x = "Sample", y = "Centered Intensity") +
  ylim(y_limits_o2) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

# 3. After Batch Correction
ggplot(df_vis_o2, aes(x = Sample, y = After_Batch_Correction)) +
  geom_line(color = "#2a9d8f", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "3. After Batch Correction", x = "Sample", y = "Centered Intensity") +
  ylim(y_limits_o2) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

# 4. Time Component
ggplot(df_vis_o2, aes(x = Sample)) +
  geom_line(aes(y = After_Batch_Correction), color = "#2a9d8f", size = 1, alpha = 0.5) +
  geom_line(aes(y = Time_Component), color = "#457b9d", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "4. Time Component", x = "Sample", y = "Centered Intensity") +
  ylim(y_limits_o2) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

# 5. Final Corrected Signal
ggplot(df_vis_o2, aes(x = Sample, y = Fully_Corrected)) +
  geom_line(color = "#264653", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "5. Final Corrected Signal", x = "Sample", y = "Centered Intensity") +
  ylim(y_limits_o2) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

```

The plots below demonstrate that the final corrected signal remains consistent, regardless of the order in which external effects are removed.

### 5.2. Joint Correction

```{r joint, fig.width=6, fig.height=2, echo=FALSE}
# Build visualization dataframe
example_cluster <- intensities[, 18]

# Calcular la mitjana del senyal original
signal_mean <- mean(example_cluster)

# Construir dataframe amb senyals centrades
df_vis <- data.frame(
  Sample = 1:length(example_cluster),
  Original = example_cluster - signal_mean,
  Projection_Both = projection_both[, 18],
  Corrected = intensities_final[, 18] - signal_mean
)

# Límits comuns per a l’eix Y
y_limits <- range(df_vis)

# 1. Original Signal
ggplot(df_vis, aes(x = Sample, y = Original)) +
  geom_line(color = "#253494", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "1. Original Signal", x = "Sample", y = "Centered Intensity") +
  ylim(y_limits) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

# 2. Projection (Elapsed Time + Batch)
ggplot(df_vis, aes(x = Sample, y = Projection_Both)) +
  geom_line(aes(y = Original), color = "#1D3557", size = 1, alpha = 0.5) +
  geom_line(color = "#e9c46a", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "2. Projection onto External Variables",
       x = "Sample", y = "Centered Intensity") +
  ylim(y_limits) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

# 3. Corrected Signal
ggplot(df_vis, aes(x = Sample, y = Corrected)) +
  geom_line(color = "#006d2c", size = 1) +
  theme_minimal(base_size = 9) +
  labs(title = "3. Corrected Signal", x = "Sample", y = "Centered Intensity") +
  ylim(y_limits) +
  theme(plot.title = element_text(size = 10, hjust = 0.5),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank())

```

## 6. Results

### 6.1 Variance Explained

Variance explained before and after correction:

```{r explained-variance}
explained_variance <- function(data, variable){
  apply(data, 2, function(x){ summary(lm(x ~ variable))$r.squared }) %>% mean()
}

# Variance explained before correction
elapsed_original <- explained_variance(intensities, df$elapsed_time)
batch_original <- explained_variance(intensities, df$batch)

# Variance explained after correction (with both variables at once)
elapsed_corrected <- explained_variance(intensities_final, df$elapsed_time)
batch_corrected <- explained_variance(intensities_final, df$batch)

# Build summary dataframe
variance_df <- data.frame(
  Condition = c("Original", "Corrected (Elapsed + Batch)"),
  Elapsed_Time = paste0(round(c(elapsed_original, elapsed_corrected) * 100, 2), " %"),
  Batch = paste0(round(c(batch_original, batch_corrected) * 100, 2), " %")
)

print(variance_df)
```

The reduction in explained variance after correction confirms the effective removal of systematic variability due to elapsed time and batch effects.

### 6.2 Principal Component Analysis (PCA) Visualizations

To better understand the structure of the data and the impact of the orthogonalization steps, we perform a Principal Component Analysis (PCA) on the cluster intensity matrix. The PCA is first computed on the original, uncorrected data, and the resulting components are used as a reference space for later projections.

```{r pca-original-dataframe, echo=FALSE}
# Scale original data before PCA
intensities_scaled <- scale(intensities)

# Perform PCA on original
pca <- prcomp(intensities_scaled)

# Explained variance
explained_var <- summary(pca)$importance[2, ] * 100
axis_labels <- paste0("PC", 1:2, " (", round(explained_var[1:2], 1), "%)")

# PCA dataframe
pca_df <- data.frame(
  PC1 = pca$x[, 1],
  PC2 = pca$x[, 2],
  Elapsed_Time = df$elapsed_time,
  Batch = as.factor(df$batch)
)
```

```{r pca-originals, echo=FALSE, warning=FALSE, fig.width=12, fig.height=4.5, fig.cap = "PCA of original data colored by elapsed time (left) and by batch (right)", fig.align='center'}

p1 <- plot_pca(pca_df, "Elapsed_Time", "Colored by Elapsed Time",
               scale_color_gradientn(colours = hcl.colors(100, "YlGnBu")))
p2 <- plot_pca(pca_df, "Batch", "Colored by Batch", scale_color_discrete())
p1 + p2

```

```{r pca-variance-distribution, echo=FALSE, warning=FALSE, fig.width=5, fig.height=3, fig.cap = "Variance explained by each principal component (original data)", fig.align='center'}

var_df <- data.frame(PC = paste0("PC", 1:6),
                     Variance = explained_var[1:6])

ggplot(var_df, aes(x = PC, y = Variance)) +
  geom_col(fill = "#A8DADC") +
  theme_minimal(base_size = 13) +
  labs(title = "PCA Components — Variance Explained",
       x = "Principal Component", y = "Explained Variance (%)") +
  theme(axis.text.x = element_text(size = 11))
```

#### Elapsed Time Correction

The first step is to correct for elapsed time. Both the original and the time-corrected datasets are projected into the same PCA space.

```{r pca-correction-elapsed-fixed, echo=FALSE, warning=FALSE, fig.width=12, fig.height=4.5, fig.cap = "Projection before (left) and after (right) elapsed time correction, both colored by elapsed time", fig.align='center'}

# Project time-corrected data
projected_time <- scale(intensities_time_corr_o1,
                        center = attr(intensities_scaled, "scaled:center"),
                        scale = attr(intensities_scaled, "scaled:scale")) %*% pca$rotation

plot_pca_2(
  data1 = pca_df,
  data2 = data.frame(PC1 = projected_time[,1], PC2 = projected_time[,2], Elapsed_Time = df$elapsed_time),
  color_var = "Elapsed_Time",
  title1 = "Original",
  title2 = "After Time Correction",
  color_scale = scale_color_gradientn(colours = hcl.colors(100, "YlGnBu"))
)

```

#### Batch Correction

We now correct for batch effects only, leaving elapsed time uncorrected.

```{r pca-correction-batch, echo=FALSE, warning=FALSE, fig.width=12, fig.height=4.5, fig.cap = "Projection before (left) and after (right) batch correction, both colored by batch", fig.align='center'}
# Project batch-corrected data
projected_batch <- scale(intensities_batch_corr_o2,
                         center = attr(intensities_scaled, "scaled:center"),
                         scale = attr(intensities_scaled, "scaled:scale")) %*% pca$rotation

plot_pca_2(
  data1 = pca_df,
  data2 = data.frame(PC1 = projected_batch[,1], PC2 = projected_batch[,2], Batch = as.factor(df$batch)),
  color_var = "Batch",
  title1 = "Original",
  title2 = "After Batch Correction",
  color_scale = scale_color_discrete()
)
```

#### Full Correction

We now compare the full correction (elapsed time + batch) against the original data. Both datasets are projected into the same PCA space.

```{r pca-correction-full, echo=FALSE, warning=FALSE, fig.width=10, fig.height=4.5, fig.cap = "Projection before (left) and after (right) full correction (no coloring)", fig.align='center'}

# Project fully corrected data into the original PCA space
projected_full <- scale(intensities_final,
                        center = attr(intensities_scaled, "scaled:center"),
                        scale = attr(intensities_scaled, "scaled:scale")) %*% pca$rotation

# Datasets sense color
data1 <- data.frame(PC1 = pca$x[,1], PC2 = pca$x[,2])
data2 <- data.frame(PC1 = projected_full[,1], PC2 = projected_full[,2])

p1 <- ggplot(data1, aes(x = PC1, y = PC2)) +
  geom_point(size = 2, color = "#888888") +
  coord_cartesian(xlim = range(c(data1$PC1, data2$PC1)),
                  ylim = range(c(data1$PC2, data2$PC2))) +
  theme_minimal(base_size = 13) +
  labs(title = "Original", x = axis_labels[1], y = axis_labels[2]) +
  theme(plot.title = element_text(size = 12, hjust = 0.5))

p2 <- ggplot(data2, aes(x = PC1, y = PC2)) +
  geom_point(size = 2, color = "#1D3557") +
  coord_cartesian(xlim = range(c(data1$PC1, data2$PC1)),
                  ylim = range(c(data1$PC2, data2$PC2))) +
  theme_minimal(base_size = 13) +
  labs(title = "After Full Correction", x = axis_labels[1], y = axis_labels[2]) +
  theme(plot.title = element_text(size = 12, hjust = 0.5))

p1 + p2
```

#### PCA After Correction

Finally, we perform a new PCA using the fully corrected dataset. The plots below show the distribution of samples in the new PCA space, colored by elapsed time and batch, respectively. A barplot of the explained variance is also included.

```{r pca-corrected-plot, echo=FALSE, warning=FALSE, fig.width=12, fig.height=4.5, fig.cap = "PCA of corrected data colored by elapsed time (left) and by batch (right)", fig.align='center'}

# PCA on corrected data
pca_corrected <- prcomp(scale(intensities_final))
explained_var_corr <- summary(pca_corrected)$importance[2, ] * 100
axis_labels <- paste0("PC", 1:2, " (", round(explained_var_corr[1:2], 1), "%)")

pca_df_corr <- data.frame(PC1 = pca_corrected$x[,1], PC2 = pca_corrected$x[,2],
                          Elapsed_Time = df$elapsed_time,
                          Batch = as.factor(df$batch))

p1 <- plot_pca(pca_df_corr, "Elapsed_Time", "Colored by Elapsed Time",
               scale_color_gradientn(colours = hcl.colors(100, "YlGnBu")))

p2 <- plot_pca(pca_df_corr, "Batch", "Colored by Batch",
               scale_color_discrete())

p1 + p2
```

```{r pca-variance-distribution-corr, echo=FALSE, warning=FALSE, fig.width=5, fig.height=3, fig.cap = "Variance explained by each principal component (corrected data)", fig.align='center'}

var_df_corr <- data.frame(PC = paste0("PC", 1:6),
                          Variance = explained_var_corr[1:6])

ggplot(var_df_corr, aes(x = PC, y = Variance)) +
  geom_col(fill = "#A8DADC") +
  theme_minimal(base_size = 13) +
  labs(title = "Corrected PCA — Variance Explained",
       x = "Principal Component", y = "Explained Variance (%)") +
  theme(axis.text.x = element_text(size = 11))

```
