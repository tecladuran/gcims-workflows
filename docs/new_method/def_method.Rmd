---
title: "Mean-based Estimation of Acquisition Effects in GC-IMS Data"
author: "Tecla Duran Fort"
date: "`r Sys.Date()`"
output:
  github_document:
    toc: yes
  html_document:
    toc: yes
    df_print: paged
  pdf_document:
    toc: yes
    fig_caption: yes
always_allow_html: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,
                      fig.path = "batch_inf_files/figure-latex/")
library(ggplot2)
library(dplyr)
library(tidyr)
library(tibble)
library(BiocParallel)
library(kableExtra)
library(RColorBrewer)
library(reshape2)

source("../../load_gcims_tools.R")
```

```{r, echo=FALSE}
plot_pca <- function(data, color_var, title, color_scale) {
  ggplot(data, aes_string(x = "PC1", y = "PC2", color = color_var)) +
    geom_point(size = 2) +
    color_scale +
    theme_minimal() +
    labs(title = title, x = axis_labels[1], y = axis_labels[2])+
    theme(
    plot.title = element_text(size = 12, hjust = 0.5))
}

scale_batch<-scale_color_discrete()
scale_time<-scale_color_manual(
  values = colorRampPalette(brewer.pal(9, "YlGnBu"))(15)
)

plot_heatmap <- function(mat, title,
                         xlab = "", ylab = "") {
  
  # Assignem noms si n'hi ha
  if (is.null(rownames(mat))) {
    rownames(mat) <- 1:nrow(mat)  # placeholder silenciós
    show_rownames <- FALSE
  } else {
    show_rownames <- TRUE
  }
  
  if (is.null(colnames(mat))) {
    colnames(mat) <- 1:ncol(mat)  # placeholder silenciós
    show_colnames <- FALSE
  } else {
    show_colnames <- TRUE
  }
  
  # Comprovar mida
  if (nrow(mat) > 100) show_rownames <- FALSE
  if (ncol(mat) > 100) show_colnames <- FALSE
  
  df_melt <- reshape2::melt(mat)
  
  # Invertir files perquè la fila 1 quedi a dalt
  df_melt$Var1 <- factor(df_melt$Var1, levels = rev(unique(df_melt$Var1)))
  
  p <- ggplot(df_melt, aes(x = Var2, y = Var1, fill = value)) +
    geom_tile() +
    scale_fill_gradient(low = "white", high = "navy") +
    labs(title = title, x = xlab, y = ylab) +
    theme_minimal() +
    theme(
      axis.ticks = element_blank(),
      panel.grid = element_blank(),
      plot.title = element_text(hjust = 0.5, size = 12)
    )
  
  # Control de text d’eixos
  if (show_colnames) {
    p <- p + theme(axis.text.x = element_text(
      angle = 90, vjust = 0.5, hjust = 1, size = 6
    ))
  } else {
    p <- p + theme(axis.text.x = element_blank())
  }
  
  if (show_rownames) {
    p <- p + theme(axis.text.y = element_text(size = 6))
  } else {
    p <- p + theme(axis.text.y = element_blank())
  }
  
  return(p)
}


```

\newpage

# Set Up
## Load Data

```{r load-data}
df <- read.csv("../../data/peak_table_var.csv")
```

## Prepare Matrices
```{r prepare-matrices}
# Prepare Matrices

# PEAK TABLE
X <- as.matrix(df %>% dplyr::select(starts_with("Cluster")))

# VARIABLES

# Vector batch (samples x 1)
batch <- df$batch

# Matriu B: one-hot encoding (samples x nbatches)
nbatch <- length(unique(batch))
B <- model.matrix(~ 0 + factor(batch))   # 135 x nbatch
colnames(B) <- paste0("Batch_", sort(unique(batch)))


# Índex d'ordre dins de cada batch (1, 2, 3, ...)
df <- df %>%
  arrange(batch, elapsed_time) %>%
  group_by(batch) %>%
  mutate(order_in_batch = row_number()) %>%
  ungroup()

order_in_batch <- df$order_in_batch

# One-hot encoding
max_order <- max(order_in_batch)

O <- model.matrix(~ 0 + factor(order_in_batch, levels = 1:max_order))
colnames(O) <- paste0("Ord_", 1:max_order)

```

```{r}
plot_heatmap(
  X, 
  title = "Peak Table (X)", 
  xlab = "Features (Clusters)", 
  ylab = "Samples"
)

# Heatmap de la matriu de batches
plot_heatmap(
  B, 
  title = "Batch One-Hot Encoding (B)", 
  xlab = "Batch categories", 
  ylab = "Samples"
)

# Heatmap de l'ordre dins de batch
plot_heatmap(
  O, 
  title = "Order-in-Batch One-Hot Encoding (O)", 
  xlab = "Order in batch", 
  ylab = "Samples"
)
```

# Batch Effect

## Batch-wise Mean Intensity Calculation

```{r batch-mean}
batch_sizes <- as.vector(t(B) %*% rep(1, nrow(X))) # vector de llargada 9
batch_sums <- t(B) %*% X # 9 x 50

M <- sweep(batch_sums, 1, batch_sizes, "/")   # 9 x 50
rownames(M) <- colnames(B)  
colnames(M) <- colnames(X)    

X_batch_means <- B %*% M   # 135 x 50
rownames(X_batch_means) <- rownames(X)
colnames(X_batch_means) <- colnames(X)
```

```{r hm-Xbatchmeans, fig.width=6, fig.height=5}
plot_heatmap(
  X_batch_means,
  title = "Batch-Reconstructed Data (X_batch_means)",
  xlab = "Features (Clusters)",
  ylab = "Samples"
)
```

```{r variance-batch-means, fig.width=5, fig.height=4}
# Variància total de les dades originals
var_total <- sum(apply(X, 2, var))

# Variància total de les dades reconstruïdes amb les mitjanes de batch
var_batch_means <- sum(apply(X_batch_means, 2, var))

# Percentatge explicat
perc_explained_batch <- 100 * var_batch_means / var_total

# Imprimir en format maco
cat(sprintf("Variance explained by batch-wise means: %.2f%%\n", perc_explained_batch))
```
## PCA of Batch-Reconstructed Data

PCA is applied to the batch-reconstructed dataset (`X_batch_means`) in order to analyse the common batch effect.

* By construction, this matrix only contains the **average batch profile**, i.e. the part of the signal shared by all samples within the same batch.
* The **scores** (`pca_batch$x`) show how samples are separated along the principal components, reflecting the strength and direction of the batch influence.
* The **loadings** (`pca_batch$rotation`) reveal whether the batch effect is distributed uniformly across all compounds or if it is driven by specific features.

This analysis helps to determine if the batch effect acts as a global shift in intensity or if it affects certain compounds more strongly than others.


```{r pca-batch}

# PCA sobre la matriu de mitjanes per batch
pca_batch <- prcomp(X_batch_means, scale. = TRUE)

# Scores (coordenades de les mostres en PC1, PC2, ...)
scores <- pca_batch$x

# Loadings (direccions dels compostos)
loadings <- pca_batch$rotation

```

```{r var-exp, fig.width=4, fig.height=3, echo=FALSE}
# Variància explicada
var_explained <- pca_batch$sdev^2 / sum(pca_batch$sdev^2)
df_var <- data.frame(
  PC = paste0("PC", 1:5),
  Variance = var_explained[1:5] * 100
)

# Bar plot amb ggplot
ggplot(df_var, aes(x = PC, y = Variance)) +
  geom_bar(stat = "identity", fill = "navy") +
  geom_text(aes(label = sprintf("%.1f%%", Variance)),
            vjust = -0.5, size = 2.5) +
  labs(title = "Explained Variance (Top 5 PCs)",
       x = "Principal Components",
       y = "Variance Explained (%)") +
  theme_minimal(base_size = 10)

```


```{r pc1-batch-plot, fig.width=6, fig.height=4}
scores <- as.data.frame(pca_batch$x)
scores$Sample <- 1:nrow(scores)
scores$Batch <- df$batch

n_batches <- length(unique(scores$Batch))
palette_yb <- brewer.pal(min(max(3, n_batches), 9), "YlGnBu")

# PC1 vs Sample index
ggplot(scores, aes(x = Sample, y = PC1, color = factor(Batch))) +
  geom_point(size = 1.5) +
  geom_line(aes(group = 1), alpha = 0.7, color = "grey10") +
  scale_color_manual(values = palette_yb) +
  labs(title = "PC1 scores across samples",
       x = "Sample index",
       y = "PC1 score",
       color = "Batch") +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "right"
  )

# PC2 vs Sample index
ggplot(scores, aes(x = Sample, y = PC2, color = factor(Batch))) +
  geom_point(size = 1.5) +
  geom_line(aes(group = 1), alpha = 0.7, color = "grey10") +
  scale_color_manual(values = palette_yb) +
  labs(title = "PC2 scores across samples",
       x = "Sample index",
       y = "PC2 score",
       color = "Batch") +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "right"
  )

```



```{r pc1-pc2-original-variance}
# PC1 vector from PCA on batch means (done with scale.=FALSE)
v <- pca_batch$rotation[,1]

# Center X with the same column means used in PCA
X_centered <- scale(X, center = pca_batch$center, scale = FALSE)

# Project onto PC1
proj <- X_centered %*% v
X_proj <- proj %*% t(v)

# Variance explained
var_total <- sum(X_centered^2)
var_explained <- sum(X_proj^2)

perc_explained <- 100 * var_explained / var_total
cat(sprintf("PC1 from batch-means explains %.2f%% of variance in the original peak table.\n", perc_explained))


```

# Time/Order Effect

## Order-wise Mean Intensity Calculation

```{r order-mean}
order_sizes <- as.vector(t(O) %*% rep(1, nrow(X))) # vector de llargada 9
order_sums <- t(O) %*% X # 9 x 50

M <- sweep(order_sums, 1, batch_sizes, "/")   # 9 x 50
rownames(M) <- colnames(O)  
colnames(M) <- colnames(X)    

X_order_means <- O %*% M   # 135 x 50
rownames(X_order_means) <- rownames(X)
colnames(X_order_means) <- colnames(X)
```

```{r}
plot_heatmap(
  X_order_means,
  title = "Batch-Reconstructed Data (X_batch_means)",
  xlab = "Features (Clusters)",
  ylab = "Samples"
)
```

