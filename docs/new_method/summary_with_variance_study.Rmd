---
title: "Mean-based Estimation of Acquisition Effects in GC-IMS Data"
author: "Tecla Duran Fort"
date: "`r Sys.Date()`"
output:
  github_document:
    toc: yes
  html_document:
    toc: yes
    df_print: paged
  pdf_document:
    toc: yes
    fig_caption: yes
always_allow_html: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,
                      fig.path = "summary_variance/figure-latex/")
library(ggplot2)
library(dplyr)
library(tidyr)
library(tibble)
library(BiocParallel)
library(kableExtra)
library(RColorBrewer)
library(reshape2)

source("../../load_gcims_tools.R")
```

```{r, echo=FALSE}
plot_pca <- function(data, color_var, title, color_scale) {
  ggplot(data, aes_string(x = "PC1", y = "PC2", color = color_var)) +
    geom_point(size = 2) +
    color_scale +
    theme_minimal() +
    labs(title = title, x = axis_labels[1], y = axis_labels[2])+
    theme(
    plot.title = element_text(size = 12, hjust = 0.5))
}

scale_batch<-scale_color_discrete()
scale_time<-scale_color_manual(
  values = colorRampPalette(brewer.pal(9, "YlGnBu"))(15)
)

plot_heatmap <- function(mat, title,
                         xlab = "", ylab = "") {
  
  # Assignem noms si n'hi ha
  if (is.null(rownames(mat))) {
    rownames(mat) <- 1:nrow(mat)  # placeholder silenciós
    show_rownames <- FALSE
  } else {
    show_rownames <- TRUE
  }
  
  if (is.null(colnames(mat))) {
    colnames(mat) <- 1:ncol(mat)  # placeholder silenciós
    show_colnames <- FALSE
  } else {
    show_colnames <- TRUE
  }
  
  # Comprovar mida
  if (nrow(mat) > 100) show_rownames <- FALSE
  if (ncol(mat) > 100) show_colnames <- FALSE
  
  df_melt <- reshape2::melt(mat)
  
  # Invertir files perquè la fila 1 quedi a dalt
  df_melt$Var1 <- factor(df_melt$Var1, levels = rev(unique(df_melt$Var1)))
  
  p <- ggplot(df_melt, aes(x = Var2, y = Var1, fill = value)) +
    geom_tile() +
    scale_fill_gradient(low = "white", high = "navy") +
    labs(title = title, x = xlab, y = ylab) +
    theme_minimal() +
    theme(
      axis.ticks = element_blank(),
      panel.grid = element_blank(),
      plot.title = element_text(hjust = 0.5, size = 12)
    )
  
  # Control de text d’eixos
  if (show_colnames) {
    p <- p + theme(axis.text.x = element_text(
      angle = 90, vjust = 0.5, hjust = 1, size = 6
    ))
  } else {
    p <- p + theme(axis.text.x = element_blank())
  }
  
  if (show_rownames) {
    p <- p + theme(axis.text.y = element_text(size = 6))
  } else {
    p <- p + theme(axis.text.y = element_blank())
  }
  
  return(p)
}


```

\newpage

# Set Up
## Load Data

```{r load-data}
df <- read.csv("../../data/peak_table_var.csv")
```

## Prepare Matrices
```{r prepare-matrices}
# Prepare Matrices

# PEAK TABLE
X <- as.matrix(df %>% dplyr::select(starts_with("Cluster")))

# VARIABLES

# Vector batch (samples x 1)
batch <- df$batch

# B: one-hot encoding (samples x nbatches)
nbatch <- length(unique(batch))
B <- model.matrix(~ 0 + factor(batch))   # 135 x nbatch
colnames(B) <- paste0("Batch_", sort(unique(batch)))


# Order Index
df <- df %>%
  arrange(batch, elapsed_time) %>%
  group_by(batch) %>%
  mutate(order_in_batch = row_number()) %>%
  ungroup()

order_in_batch <- df$order_in_batch

# One-hot encoding
max_order <- max(order_in_batch)

O <- model.matrix(~ 0 + factor(order_in_batch, levels = 1:max_order))
colnames(O) <- paste0("Ord_", 1:max_order)

```

```{r, echo=FALSE}
p1<-plot_heatmap(
  X, 
  title = "Peak Table (X)", 
  xlab = "Features (Clusters)", 
  ylab = "Samples"
)

# Heatmap de la matriu de batches
p2<-plot_heatmap(
  B, 
  title = "Batch One-Hot Encoding (B)", 
  xlab = "Batch categories", 
  ylab = "Samples"
)

# Heatmap de l'ordre dins de batch
p3<-plot_heatmap(
  O, 
  title = "Order-in-Batch One-Hot Encoding (O)", 
  xlab = "Order in batch", 
  ylab = "Samples"
)
```
```{r, echo=FALSE}
p1
```
```{r, echo=FALSE, fig.width=10, fig.height=4}
p2+p3
```


# Batch Effect

## Batch-wise Mean Intensity Calculation

```{r batch-mean}
batch_sizes <- as.vector(t(B) %*% rep(1, nrow(X))) # vector de llargada 9
batch_sums <- t(B) %*% X # 9 x 50

M <- sweep(batch_sums, 1, batch_sizes, "/")   # 9 x 50
rownames(M) <- colnames(B)  
colnames(M) <- colnames(X)    

X_batch_means <- B %*% M   # 135 x 50
rownames(X_batch_means) <- rownames(X)
colnames(X_batch_means) <- colnames(X)
```

```{r hm-Xbatchmeans, fig.width=6, fig.height=5, echo=FALSE}
plot_heatmap(
  X_batch_means,
  title = "Batch-Reconstructed Data (X_batch_means)",
  xlab = "Features (Clusters)",
  ylab = "Samples"
)
```


## PCA of Batch-Reconstructed Data

PCA is applied to the batch-reconstructed dataset (`X_batch_means`) in order to analyse the common batch effect.

* By construction, this matrix only contains the **average batch profile**, i.e. the part of the signal shared by all samples within the same batch.
* The **scores** (`pca_batch$x`) show how samples are separated along the principal components, reflecting the strength and direction of the batch influence.
* The **loadings** (`pca_batch$rotation`) reveal whether the batch effect is distributed uniformly across all compounds or if it is driven by specific features.

This analysis helps to determine if the batch effect acts as a global shift in intensity or if it affects certain compounds more strongly than others.


```{r pca-batch, echo=TRUE}
# PCA on the matrix of batch-wise means
pca_batch <- prcomp(X_batch_means, scale. = TRUE)

# Scores (coordinates of the samples in PC1, PC2, ...)
scores_batch <- pca_batch$x

# Loadings (directions of the clusters/features)
loadings <- pca_batch$rotation
```

```{r var-exp, echo=TRUE}
# Variance Explained by the PCs
var_pca_batch <- pca_batch$sdev^2 / sum(pca_batch$sdev^2)
```

```{r var-exp-p, fig.width=4, fig.height=3, echo=FALSE}
df_var <- data.frame(
  PC = paste0("PC", 1:5),
  Variance = var_pca_batch[1:5] * 100
)

# Bar plot amb ggplot
ggplot(df_var, aes(x = PC, y = Variance)) +
  geom_bar(stat = "identity", fill = "navy") +
  geom_text(aes(label = sprintf("%.1f%%", Variance)),
            vjust = -0.5, size = 2.5) +
  labs(title = "Explained Variance (Top 5 PCs)",
       x = "Principal Components",
       y = "Variance Explained (%)") +
  theme_minimal(base_size = 10)

```


```{r pc1-batch-plot, fig.width=6, fig.height=4, echo=FALSE}
scores_batch_df <- as.data.frame(scores_batch)
scores_batch_df$Sample <- 1:nrow(scores_batch)
scores_batch_df$Batch <- df$batch

n_batches <- length(unique(scores_batch_df$Batch))
palette_yb <- brewer.pal(min(max(3, n_batches), 9), "YlGnBu")

# PC1 vs Sample index
ggplot(scores_batch_df, aes(x = Sample, y = PC1, color = factor(Batch))) +
  geom_point(size = 1.5) +
  geom_line(aes(group = 1), alpha = 0.7, color = "grey10") +
  scale_color_manual(values = palette_yb) +
  labs(title = "PC1 scores across samples",
       x = "Sample index",
       y = "PC1 score",
       color = "Batch") +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "right"
  )

# PC2 vs Sample index
ggplot(scores_batch_df, aes(x = Sample, y = PC2, color = factor(Batch))) +
  geom_point(size = 1.5) +
  geom_line(aes(group = 1), alpha = 0.7, color = "grey10") +
  scale_color_manual(values = palette_yb) +
  labs(title = "PC2 scores across samples",
       x = "Sample index",
       y = "PC2 score",
       color = "Batch") +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "right"
  )

```

## Variance Explained

### Total variance explained by batch-wise means
This calculation shows the fraction of the total variance in the peak table that can be reconstructed using only batch-wise averages.It quantifies the overall batch effect as a percentage of the total variance.

```{r variance-b, echo=TRUE}
# Total Variance in the original data
var_total <- sum(apply(X, 2, var))

# Total Variance in the reconstructed batch-wise means data
var_batch_means <- sum(apply(X_batch_means, 2, var))

# Percentage explained
perc_explained_batch <- 100 * var_batch_means / var_total
```

```{r, echo=FALSE}
cat(sprintf("Variance explained by batch-wise means: %.2f%%\n", perc_explained_batch))
```

### Variance explained by the first principal component
Here we compute how much of the total variance in `X` is explained when projecting the original data onto the direction of the first principal component (obtained from the batch-wise means, in the sample space).

```{r, echo=TRUE}
# First PC 
t1 <- scores_batch[,1, drop=FALSE]
# Normalization
t1 <- t1 / sqrt(sum(t1^2))

# Center X
X_centered <- scale(X, center = TRUE, scale = FALSE)

# Project X to PC1 in sample space
proj1 <- t1 %*% t(t1) %*% X_centered

# Explained Variance
var_explained_pc1 <- sum(apply(proj1, 2, var))
```

```{r, echo=FALSE}
perc_explained_pc1 <- 100 * var_explained_pc1 / var_total
cat(sprintf("PC1 explains %.2f%% of variance in X.\n",
            perc_explained_pc1))
```

### Variance explained across components 
The following comparison is shown for the first eight principal components:
- **PCA**: variance explained according to the standard PCA of the batch means.
- **In X**: variance explained when these components are applied to the original data matrix `X`.

Only eight components are reported because, after centering, the batch design matrix has a rank of *nbatch – 1*.  
With nine batches in total, this subspace can have at most eight linearly independent directions of variability.  
Consequently, the batch effect can be decomposed into a maximum of eight non-zero principal components.

```{r, echo=TRUE}
# Variance explained in the original data (sample space)
scores_batch_norm <- apply(scores_batch, 2, function(t) t / sqrt(sum(t^2)))

explained_in_X <- sapply(1:8, function(i) {
  T <- scores_batch_norm[, i, drop = FALSE]
  proj <- T %*% t(T) %*% X_centered
  sum(apply(proj, 2, var)) / var_total * 100
})
```


```{r, echo=FALSE, fig.width=10, fig.height=4}
# --- Data frame base ---
df_comp <- data.frame(
  PC = 1:8,
  PCA = var_pca_batch[1:8]* 100,
  InX = explained_in_X
)

df_long <- pivot_longer(df_comp, cols = c("PCA", "InX"),
                        names_to = "Type", values_to = "Variance")

# --- 1. Variance explained per component ---
p1 <- ggplot(df_long, aes(x = PC, y = Variance, color = Type)) +
  geom_point(size = 2) +
  geom_line(aes(group = Type), linewidth = 0.7) +
  scale_color_manual(values = c("PCA" = "navy", "InX" = "darkorange")) +
  scale_x_continuous(breaks = 1:8) +
  theme_minimal(base_size = 12) +
  labs(title = "Variance explained per component",
       x = "Principal Component",
       y = "Variance explained (%)",
       color = "")

# --- 2. Variance explained acumulada ---
df_cum <- df_comp
df_cum$PCA <- cumsum(df_cum$PCA)
df_cum$InX <- cumsum(df_cum$InX)

df_cum_long <- pivot_longer(df_cum, cols = c("PCA", "InX"),
                            names_to = "Type", values_to = "CumVariance")

p2 <- ggplot(df_cum_long, aes(x = PC, y = CumVariance, color = Type)) +
  geom_point(size = 2) +
  geom_line(aes(group = Type), linewidth = 0.7) +
  scale_color_manual(values = c("PCA" = "navy", "InX" = "darkorange")) +
  scale_x_continuous(breaks = 1:8) +
  theme_minimal(base_size = 12) +
  labs(title = "Cumulative variance explained (PC1–PC8)",
       x = "Principal Component",
       y = "Cumulative variance explained (%)",
       color = "") +
  geom_hline(yintercept = 100, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = perc_explained_batch, 
             linetype = "dotted", color = "black") +
  annotate("text", x = 8.2, y = perc_explained_batch + 1,
           label = sprintf("Batch means (%.1f%%)", perc_explained_batch),
           hjust = 1, vjust = 0, size = 3, color = "black")


p1+p2

```


# Time/Order Effect

## Order-wise Mean Intensity Calculation

```{r order-mean}
order_sizes <- as.vector(t(O) %*% rep(1, nrow(X)))
order_sums <- t(O) %*% X

M <- sweep(order_sums, 1, order_sizes, "/") 
rownames(M) <- colnames(O)  
colnames(M) <- colnames(X)    

X_order_means <- O %*% M  
rownames(X_order_means) <- rownames(X)
colnames(X_order_means) <- colnames(X)
```

```{r, echo=FALSE}
plot_heatmap(
  X_order_means,
  title = "Batch-Reconstructed Data (X_batch_means)",
  xlab = "Features (Clusters)",
  ylab = "Samples"
)
```

## PCA of Order-Reconstructed Data

PCA is applied to the order-reconstructed dataset (`X_order_means`) in order to analyse the common order effect.

```{r pca-order}
# PCA on the matrix of order-wise means
pca_order <- prcomp(X_order_means, scale. = TRUE)

# Scores 
scores_order <- pca_order$x

# Loadings (directions of the clusters/features)
loadings <- pca_order$rotation
```

```{r var-exp-o, echo=TRUE}
# Variance Explained by the PCs
var_pca_order <- pca_order$sdev^2 / sum(pca_order$sdev^2)
```

```{r var-exp-o-p, fig.width=4, fig.height=3, echo=FALSE}
df_var <- data.frame(
  PC = paste0("PC", 1:5),
  Variance = var_pca_order[1:5] * 100
)

# Bar plot amb ggplot
ggplot(df_var, aes(x = PC, y = Variance)) +
  geom_bar(stat = "identity", fill = "navy") +
  geom_text(aes(label = sprintf("%.1f%%", Variance)),
            vjust = -0.5, size = 2.5) +
  labs(title = "Explained Variance (Top 5 PCs)",
       x = "Principal Components",
       y = "Variance Explained (%)") +
  theme_minimal(base_size = 10)

```
\newline
```{r pc1-order-plot, fig.width=10, fig.height=4, echo=FALSE}
scores_order_df <- as.data.frame(scores_order)
scores_order_df$Sample <- 1:nrow(scores_order)
scores_order_df$Order <- df$order_in_batch

n_orders <- length(unique(scores_order_df$Order))
palette_yb <- colorRampPalette(brewer.pal(9, "YlGnBu"))(n_orders)

# PC1 vs Sample index
ggplot(scores_order_df, aes(x = Sample, y = PC1, color = factor(Order))) +
  geom_point(size = 2) +
  geom_line(aes(group = 1), alpha = 0.7, color = "grey20") +
  scale_color_manual(values = palette_yb) +
  labs(title = "PC1 scores across samples",
       x = "Sample index",
       y = "PC1 score",
       color = "Order") +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    legend.position = "right"
  )
```

## Variance Explained

### Total variance explained by order-wise means
This calculation shows the fraction of the total variance in the peak table that can be reconstructed using only order-wise averages. It quantifies the overall order effect as a percentage of the total variance.

```{r variance-o, echo=TRUE}
# Total Variance in the reconstructed order-wise means data
var_order_means <- sum(apply(X_order_means, 2, var))

# Percentage explained
perc_explained_order <- 100 * var_order_means / var_total
```

```{r, echo=FALSE}
cat(sprintf("Variance explained by order-wise means: %.2f%%\n", perc_explained_order))
```

### Variance explained by the first principal component
Here we compute how much of the total variance in `X` is explained when projecting the original data onto the direction of the first principal component (obtained from the order-wise means, in the sample space).

```{r, echo=TRUE}
# First PC 
t1 <- scores_order[,1, drop=FALSE]

# Normalization
t1 <- t1 / sqrt(sum(t1^2))

# Center X
X_centered <- scale(X, center = TRUE, scale = FALSE)

# Project X to PC1 in sample space
proj1 <- t1 %*% t(t1) %*% X_centered

# Explained variance
var_explained_pc1 <- sum(apply(proj1, 2, var))
```

```{r, echo=FALSE}
perc_explained_pc1 <- 100 * var_explained_pc1 / var_total
cat(sprintf("PC1 explains %.2f%% of variance in X.\n", perc_explained_pc1))
```

### Variance explained across components 

```{r, echo=TRUE}
# Variance explained in the original data (sample space)
scores_order_norm <- apply(scores_order, 2, function(t) t / sqrt(sum(t^2)))

explained_in_X <- sapply(1:14, function(i) {
  T <- scores_order_norm[, i, drop = FALSE]
  proj <- T %*% t(T) %*% X_centered
  sum(apply(proj, 2, var)) / var_total * 100
})
```


```{r, echo=FALSE, fig.width=10, fig.height=4}
# --- Data frame base ---
df_comp <- data.frame(
  PC = 1:14,
  PCA = var_pca_order[1:14] * 100,
  InX = explained_in_X
)

df_long <- pivot_longer(df_comp, cols = c("PCA", "InX"),
                        names_to = "Type", values_to = "Variance")

# --- 1. Variance explained per component ---
p1 <- ggplot(df_long, aes(x = PC, y = Variance, color = Type)) +
  geom_point(size = 2) +
  geom_line(aes(group = Type), linewidth = 0.7) +
  scale_color_manual(values = c("PCA" = "navy", "InX" = "darkorange")) +
  scale_x_continuous(breaks = 1:14) +
  theme_minimal(base_size = 12) +
  labs(title = "Variance explained per component",
       x = "Principal Component",
       y = "Variance explained (%)",
       color = "")

# --- 2. Cumulative variance explained ---
df_cum <- df_comp
df_cum$PCA <- cumsum(df_cum$PCA)
df_cum$InX <- cumsum(df_cum$InX)

df_cum_long <- pivot_longer(df_cum, cols = c("PCA", "InX"),
                            names_to = "Type", values_to = "CumVariance")

p2 <- ggplot(df_cum_long, aes(x = PC, y = CumVariance, color = Type)) +
  geom_point(size = 2) +
  geom_line(aes(group = Type), linewidth = 0.7) +
  scale_color_manual(values = c("PCA" = "navy", "InX" = "darkorange")) +
  scale_x_continuous(breaks = 1:14) +
  theme_minimal(base_size = 12) +
  labs(title = "Cumulative variance explained",
       x = "Principal Component",
       y = "Cumulative variance explained (%)",
       color = "") +
  geom_hline(yintercept = 100, linetype = "dashed", color = "grey40") +
  geom_hline(yintercept = perc_explained_order, 
             linetype = "dotted", color = "black") +
  annotate("text", x = 8.2, y = perc_explained_order + 1,
           label = sprintf("Order means (%.1f%%)", perc_explained_order),
           hjust = 1, vjust = 0, size = 3, color = "black")

p1+p2


```



